/***************************************************************************
                          config.cpp  -  writes and reads configuration
                             -------------------
    begin                : Sam, 15 Feb 2003
    copyright            : (C) 2003 by Heiko Köhler
    email                : heicom@users.sourceforge.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#undef slots
#include <Python.h>
#define slots
#include <qstring.h>
#include <qdir.h>
#include <qfile.h>
#include <qtextstream.h>
#include <list>

#include "config.h"
#include "cute.h"
#include "shortcuts.h"

namespace Config{

/** wites config of a python module */
static void writeModuleConfig(ConfigModule *module, QTextStream *fout);

/** stores shortcuts */
static void saveShortcuts(QTextStream &fout);

/** reads the configuration file .cuterc*/
void readConfig()
{
	QDir dir = QDir::home();
	
	if( !dir.cd(".cute") ){
	dir.cd(".cute");
		QFileInfo fi(dir, ".cute");
		if(fi.exists()){
				if(fi.isDir())
					QMessageBox::warning(qApp->mainWidget(), "CUTE", "Cannot cd into .cute");
				else
					QMessageBox::warning(qApp->mainWidget(), "CUTE", "Cannot create directory");
			}
		else{
			QMessageBox::information(qApp->mainWidget(), "CUTE", "Creating ~/.cute directory");
			if(!dir.mkdir(".cute"))
				QMessageBox::information(qApp->mainWidget(), "CUTE", "Could not create ~/.cute directory");
			else{
				dir.cd(".cute");
				if(!dir.mkdir("scripts"))
					QMessageBox::information(qApp->mainWidget(), "CUTE", "Could not create ~/.cute/scripts directory");
				if(!dir.mkdir("macros"))
					QMessageBox::information(qApp->mainWidget(), "CUTE", "Could not create ~/.cute/macros directory");
				if(!dir.mkdir("sessions"))
					QMessageBox::information(qApp->mainWidget(), "CUTE", "Could not create ~/.cute/sessions directory");
			}
		}
	}

	// if cute version >= 0.1.6 langs dir is required
	if( !QDir(QDir::homeDirPath()+QDir::separator()+".cute"+QDir::separator()+"langs").exists() ) {
		QDir destDir = QDir::home();
		destDir.cd(".cute");
		destDir.mkdir("langs");
		destDir.cd("langs");
		QDir srcDir(LANG_DIR);
	
		QString data;
		QStringList dirList = srcDir.entryList();
		for( int i = 2; i < dirList.count(); i++)
			if( QFileInfo(srcDir.absPath()+QDir::separator()+dirList[i]).isFile()) {
				QFile srcFile(srcDir.absPath()+QDir::separator()+dirList[i]);
				QFile destFile(destDir.absPath()+QDir::separator()+dirList[i]);
				if(destFile.exists())
					continue;
				QTextStream destStream(&destFile);
				QTextStream srcStream(&srcFile);
				srcFile.open(IO_ReadOnly);
				destFile.open(IO_WriteOnly);
				data = srcStream.read();
				destStream << data;
				srcFile.close();
				destFile.close();
			}
	}
	
	QFile file(QDir::homeDirPath()+"/.cuterc");
	if(!file.exists()){
		QMessageBox::information(qApp->mainWidget(), "CUTE", "Creating ~/.cuterc");
		file.open(IO_ReadOnly);
		file.close();
		return;
	}
	
	//FILE *c_file = fopen("/home/heiko/.cuterc", "r");
	//PyRun_SimpleFile(c_file, ".cuterc");
	QString const_cmd("execfile(\".cuterc\")\n");
	dir = QDir::current();
	QDir::setCurrent( QDir::homeDirPath() );
	char *cmd = new char[1024];
	strcpy(cmd, const_cmd.latin1());
	PyRun_SimpleString(cmd);

	// read language config files
	QDir langDir = QDir(QDir::homeDirPath()+QDir::separator()+".cute"+QDir::separator()+"langs");
	QStringList langEntryList = langDir.entryList();
	QString langFile;
	for( int i = 2; i < langEntryList.count(); i++ ){
		QString langFile = langDir.absPath()+QDir::separator()+langEntryList[i];
		QFileInfo fi(langDir, langFile);
		if(fi.isFile()){
			langFile = QString("execfile(\"")+langFile+QString("\")\n");
			char *cmd = strdup(langFile);
			PyRun_SimpleString( cmd );
		}
	}

	QDir::setCurrent( dir.absPath() );
}

/** writes  .cuterc file */
void writeConfig()
{
	QFile file(QDir::homeDirPath()+"/.cuterc");
	CUTE *cute = static_cast<CUTE*>(qApp->mainWidget());
	
	if( file.open(IO_WriteOnly) ){
		QTextStream fout(&file);
		fout << "#This file is automatically generated by CUTE.\n";
		fout << "#Do not modify UNLESS YOU know what you are doing.\n";
		
		//write settings
		fout << "from config import *\n";
		fout << "\n#executes user pre config\n";
		fout << "if fileExists(\"cute.pre_config\"):\n";
		fout << "\texecfile(\"cute.pre_config\")\n";
		fout << "\n#settings\n";
		writeModuleConfig(&Config::cute, &fout);
		writeModuleConfig(&edit, &fout);
		writeModuleConfig(&view, &fout);
		
		//store window geometry
		fout << "setMainWidgetGeometry(" << cute->pos().x() << ", "
			 << cute->pos().y() << ", " << cute->width() << ", " << cute->height()
			 << ")\n";
		
		// write file history
		fout << "\n#file history\n";
		std::list<std::string>::reverse_iterator iter = recentFilesList.rbegin();
		for(; iter != recentFilesList.rend(); ++iter)
			fout << "addRecentFile(\"" << iter->c_str() << "\")\n";
		fout << "\n";
		
		// write project history
		fout << "\n#project history\n";
		for(int i = recentProjectList.count(); i >= 0; i--)
			fout << "addRecentProject(\"" << recentProjectList[i] << "\")\n";
		fout << "\n";
		
		// writes shortcuts
		saveShortcuts(fout);
		
		fout << "\n#executes user post config\n";
		fout << "if fileExists(\"cute.post_config\"):\n";
		fout << "\texecfile(\"cute.post_config\")\n";
	}
}

static void writeModuleConfig(ConfigModule *module, QTextStream *fout )
{
	PyObject *key, *value;
	int pos = 0;
	QString key_str, name, enum_str, line;
	API::EnumModule *_enum;

	name = module->name();
	if(name == "config")
		name = "";
	else
		name = name + ".";
	PyObject *dict = module->dict();
	
	while(PyDict_Next(dict, &pos, &key, &value)){
		key_str = PyString_AsString(key);
		if(key_str == "__name__")
			continue;
		if(key_str == "__doc__")
			continue;
		if(key_str == "edit")
			continue;
		if(key_str == "view")
			continue;
		if(key_str == "general")
			continue;
		if(key_str == "lang")
			continue;
		if( PyInt_Check(value) ){
			int int_value = (int)PyInt_AsLong(value);
			_enum = module->getEnum(key_str.latin1());
			if(_enum){
				enum_str = QString(_enum->name()) + "." + QString(_enum->itemName(int_value));
				line = name + key_str + " = " + enum_str ;
			}
			else
				line = name + key_str + " = " + QString("%1").arg(int_value);
		}
		else if( PyString_Check(value) ){
			const char *string_value = PyString_AsString(value);
			line = name + key_str + " = \'" + string_value + "\'";
		}
		*fout << line << endl;
	}
	*fout << endl;
}

static void saveShortcuts(QTextStream &fout)
{
	QPtrList<QAction> *actions;
	QAction *action;
	
	fout << "# all shortcuts \n";
	
	actions = Shortcuts::actions();
	for( action = actions->first(); action; action = actions->next() )
		if(strlen(action->name()))
			fout << "map(\"" << action->name() << "\", \"" << (QString)action->accel() << "\")\n";
}

}	// namespace Config
